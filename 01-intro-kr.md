---
layout: page
title: 자동화와 Make
subtitle: 들어가며
minutes: 0
---

> ## 학습 목표 {.objectives}
>
> * Make가 무엇을 위한 것인지 설명한다.
> * Make가 왜 쉘 스크립트와 다른지 설명한다.
> * 인기있는 다른 빌드 도구를 살펴본다.

텍스트 파일을 읽어 들이고,
텍스트에 단어갯수를 세고, 출력을 데이터 파일에 저장하는 
`wordcount.py` 스크립트가 있다고 가정하자:

~~~ {.bash}
$ python wordcount.py books/isles.txt isles.dat
~~~

`head` 명령어를 사용해서 데이터 파일 첫 5행을 살펴본다면,

~~~ {.bash}
$ head -5 isles.dat
~~~

`isles.dat` 파일이 단어마다 한줄씩 구성된 것을 볼 수 있다.

~~~ {.output}
the 3822 6.7371760973
of 2460 4.33632998414
and 1723 3.03719372466
to 1479 2.60708619778
a 1308 2.30565838181
~~~

각 행은, 단어 자체, 해당 단어 출현횟수, 출현횟수를 텍스트 파일에 전체 단어 갯수에 대한 
백분율로 나타낸다. 또다른 예제로:

~~~ {.bash}
$ python wordcount.py books/abyss.txt abyss.dat
$ head -5 abyss.dat
~~~

~~~ {.output}
the 4044 6.35449402891
and 2807 4.41074795726
of 1907 2.99654305468
a 1594 2.50471401634
to 1515 2.38057825267
~~~

> ## 지프의 법칙(Zipf's Law) {.callout}
>
> 가장 자주 출현하는 단어는 두번째 가장 자주 출현하는 단어보다 거의 두배 나타난다.
> 이를 [지프의 법칙](https://ko.wikipedia.org/wiki/지프의_법칙), 
> [Zipf's Law](http://en.wikipedia.org/wiki/Zipf%27s_law)이라고 부른다.

`plotcount.py` 스크립트는 데이터 파일을 읽어들여, 가장 자주 출현하는 10 단어를 도식화한다:

~~~ {.bash}
$ python plotcount.py isles.dat show
~~~

윈도우를 닫아 그래프를 빠져나온다.

`plotcount.py`로 그래프를 이미지(예, JPEG)로 저장할 수도 있다:

~~~ {.bash}
$ python plotcount.py isles.dat isles.jpg
~~~

상기 스크립트를 합하면, 작업흐름은 다음을 구현한 것이 된다:

1. 데이터 파일을 읽어들인다.
2. 해당 데이터 파일에 분석을 실시한다.
3. 분석 결과를 신규 파일에 저장한다.
4. 분석 결과에 대한 그래프를 그려 도식화한다.
5. 이미지 파일로 그래프를 저장해서, 논문에 삽입할 수 있게 된다.

지금까지 작업을 수행한 것처럼, 
쉘 프롬프트에서 `wordcount.py` 와 `plotcount.py` 스크립트를 파일 한둘에 작업하는 것은 문제 없다.
하지만, 텍스트 파일이 5개, 10개, 20개가 된다면,
이런 작업은 급격히 단조로워진다.
쉘 스크립트를 작성해서 텍스트 파일에 루프를 둘려, 
결과값을 텍스트 파일에 저장하고, 순서대로 그래프를 생성할 수 있지만,
이러한 접근방법도 문제를 일으킬 수 있다.
만약 텍스트 파일이 변경되면, 모든 파일이 아니라 변경된 텍스트 파일에 대해서만
분석을 다시 실행해야 하고, 그래프를 다시 생성해야만 된다.
더욱이, 텍스트 파일이 변경되기만 하면 그럴때마다 이런 작업을 수행하고자 한다.

[Make](http://www.gnu.org/software/make/)(GNU Make로도 알려짐)는
빠르고, 자유롭게 사용가능하고, 무료이며, 문서화가 잘된 [빌드 관리자(build manager)](reference.html#build-manager)다.
Make는 1977년 벨 연구소 여름 인턴으로 근무한 Stuart Feldman에 의해 개발되었고,
오늘날까지 널리 사용되고 있다.
Make는 분석을 실행하고, 결과를 도식화하는데 필요한 명령어를 실행한다.
쉘스크립트처럼, 단일 쉘 명령어를 통해, 복잡한 순서 명령어를 실행할 수 있다.
쉘스크립트와 달리, 명시적으로 파일 사이에 존재하는 의존성을 기록해서,
텍스트 파일이 변경될 때, 데이터 파일 혹은 이미지 파일을 언제 다시 재생성할지 결정할 수 있다.
새로운 파일을 생성하는데, 파일을 처리하는 일반적인 패턴을 따르는 어떤 명령어에도 Make를 사용할 수 있다. 
예를 들어:

* 원데이터 파일에 분석 스크립트를 실행해서, 원 데이터를 요약하는 데이터를 생성한다.
* 상기 데이터에 시각화 스크립트를 실행해서, 그래프를 생성한다.
* 텍스트와 그래프를 파싱하고 조합해서 논문을 생성한다.
* 소스코드를 컴파일해서 실행 프로그램 혹은 라이브러리를 생성한다.

시중에 이용가능한 빌드 도구가 많이 있다.
예를 들어, [Apache ANT](http://ant.apache.org/), [doit](http://pydoit.org/), 
윈도우용 [nmake](https://msdn.microsoft.com/en-us/library/dd9y37ha.aspx)가 있다.
이런 빌드 도구를 사용하는 스크립트를 빌드하는 빌드 도구도 있다. 
예를 들어, [GNU Autoconf](http://www.gnu.org/software/autoconf/autoconf.html)와
[CMake](http://www.cmake.org/)가 있다.
어떤 도구가 최선인지는 요구사항, 사용 의도, 운영체제에 달려있다.
하지만, 거의 모든 빌드 도구는 Make와 동일한 기본 개념을 공유하고 있다.

> ## 거의 40살이 된 Make를 왜 사용할까? {.callout}
>
> 오늘날, 고성능 컴퓨팅에 매우 일반적인 언어인 
> C 혹은 포트란 레거시 코드를 갖고 작업한 연구원은 아마도 Make를 접해봤을 것 같다.
> 
> 재현가능한 연구 작업흐름을 구현하거나, 
> (R 혹은 파이썬을 사용해서) 자료분석과 시각화 작업을 자동화하거나,
> 텍스트를 가지고 표와 그래프를 조합해서 데출판을 위한 보고서와 논문을 작업하는데,
> Make를 사용했을 것이다. 
> 
> Make의 기본적인 개념은 거의 모든 빌드도구에 공통이다.

[GNU Make](http://www.gnu.org/software/make/)는
빠르고, 자유롭게 사용가능하고, 무료이며, 문서화가 잘 정비되어 있고,
매우 인기가 있고, Make 를 구현한 것 중 하나를 매우 잘 확장하고 있다.
이제부터, GNU Make에 집중한다. 따라서, 
Make를 언급하면, GNU Make를 의미한다.


